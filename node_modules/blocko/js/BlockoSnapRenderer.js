/// <reference path="./typings/tsd.d.ts" />
var BlockoCore_1 = require("./BlockoCore");
var BlockoSnapRenderer;
(function (BlockoSnapRenderer) {
    var MaterialIcons = {
        RemoveCircle: "\uE15C",
        Cancel: "\uE5C9",
        Settings: "\uE8B8",
    };
    var Point = (function () {
        function Point(x, y) {
            this.x = x;
            this.y = y;
        }
        Point.prototype.plus = function (p) {
            return new Point(this.x + p.x, this.y + p.y);
        };
        Point.prototype.minus = function (p) {
            return new Point(this.x - p.x, this.y - p.y);
        };
        return Point;
    })();
    BlockoSnapRenderer.Point = Point;
    var RendererController = (function () {
        function RendererController(editorElement) {
            this.rendererConfig = {
                connectionLineColorSuccess: "black",
                connectionLineColorFail: "#ccc"
            };
            this.openConfigCallback = null;
            this.currentConnectorRenderer = null;
            this.editorMainElement = editorElement;
            this.editorMainElement.className += " blocko-editor__main";
            this.editorMainElement.style.position = "relative";
            this.editorMainElement.style.overflow = "auto";
            this.editorSvgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            this.editorSvgElement.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
            this.editorSvgElement.setAttributeNS(null, "class", "blocko-editor__svg");
            this.editorMainElement.appendChild(this.editorSvgElement);
            this.editorSvgElement.style.minHeight = "100%";
            this.editorSvgElement.style.minWidth = "100%";
            this.editorSvgElement.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKAQMAAAC3/F3+AAAABlBMVEUAAAAAAAClZ7nPAAAAAnRSTlMAQABPjKgAAAALSURBVAjXY8AHHAAAXgBBoiU/swAAAABJRU5ErkJggg==)";
            this.snapPaper = Snap(this.editorSvgElement);
            this.initSnapCompnents();
        }
        RendererController.prototype.initSnapCompnents = function () {
            this.sTempConnectionLine = this.snapPaper.line(0, 0, 0, 0);
            this.sTempConnectionLine.attr({
                stroke: "#000",
                strokeWidth: 2,
                pointerEvents: "none",
                visibility: "hidden"
            });
        };
        RendererController.prototype.registerOpenConfigCallback = function (callback) {
            this.openConfigCallback = callback;
        };
        RendererController.prototype.callOpenConfigCallback = function (block) {
            if (this.openConfigCallback) {
                this.openConfigCallback(block);
            }
        };
        RendererController.prototype.cumulativeOffset = function (element) {
            var top = 0, left = 0;
            do {
                top += element.offsetTop || 0;
                left += element.offsetLeft || 0;
                element = element.offsetParent;
            } while (element);
            return {
                top: top,
                left: left
            };
        };
        RendererController.prototype.getPaperAbsolutePosition = function () {
            return this.cumulativeOffset(this.snapPaper.node);
        };
        RendererController.prototype.globalPointToLocal = function (point) {
            var pos = this.getPaperAbsolutePosition();
            return new Point(point.x - pos.left, point.y - pos.top);
        };
        RendererController.prototype.localPointToGlobal = function (point) {
            var pos = this.getPaperAbsolutePosition();
            return new Point(point.x + pos.left, point.y + pos.top);
        };
        RendererController.prototype.tempConnectionLineStart = function (connectorRenderer, point) {
            if (!connectorRenderer.connector.haveFreeSpace())
                return;
            this.currentConnectorRenderer = connectorRenderer;
            this.currentStartPoint = this.globalPointToLocal(point);
            this.currentLastPoint = this.currentStartPoint;
            var conPos = connectorRenderer.getPosition();
            this.snapPaper.add(this.sTempConnectionLine);
            this.sTempConnectionLine.attr({
                x1: conPos.x,
                y1: conPos.y,
                x2: this.currentStartPoint.x,
                y2: this.currentStartPoint.y,
                visibility: "visible",
                stroke: this.rendererConfig.connectionLineColorFail
            });
        };
        RendererController.prototype.tempConnectionLineMove = function (connectorRenderer, diffPoint) {
            if (this.currentConnectorRenderer != connectorRenderer) {
                this.sTempConnectionLine.attr({
                    visibility: "hidden"
                });
                this.currentConnectorRenderer = null;
                return;
            }
            var nowPoint = this.currentStartPoint.plus(diffPoint);
            var nowPointGlobal = this.localPointToGlobal(nowPoint);
            this.currentLastPoint = nowPoint;
            var element = Snap.getElementByPoint(nowPointGlobal.x, nowPointGlobal.y);
            var canConnect = false;
            try {
                if (element && element.hasClass(ConnectorRenderer.idClass)) {
                    var connector = element.data(ConnectorRenderer.idClass);
                    canConnect = this.currentConnectorRenderer.connector.canConnect(connector.connector);
                }
            }
            catch (error) {
            }
            this.sTempConnectionLine.attr({
                x2: nowPoint.x,
                y2: nowPoint.y,
                stroke: canConnect ? this.rendererConfig.connectionLineColorSuccess : this.rendererConfig.connectionLineColorFail
            });
        };
        RendererController.prototype.tempConnectionLineEnd = function (connectorRenderer) {
            if (this.currentConnectorRenderer != connectorRenderer) {
                this.sTempConnectionLine.attr({
                    visibility: "hidden"
                });
                this.currentConnectorRenderer = null;
                return;
            }
            var nowPoint = this.currentLastPoint;
            var nowPointGlobal = this.localPointToGlobal(nowPoint);
            var element = Snap.getElementByPoint(nowPointGlobal.x, nowPointGlobal.y);
            var canConnect = false;
            try {
                if (element && typeof element["hasClass"] == "function" && element.hasClass(ConnectorRenderer.idClass)) {
                    var connector = element.data(ConnectorRenderer.idClass);
                    canConnect = this.currentConnectorRenderer.connector.canConnect(connector.connector);
                    if (canConnect) {
                        this.currentConnectorRenderer.connector.connect(connector.connector);
                    }
                }
            }
            catch (error) {
            }
            this.sTempConnectionLine.attr({
                visibility: "hidden"
            });
            this.currentConnectorRenderer = null;
        };
        return RendererController;
    })();
    BlockoSnapRenderer.RendererController = RendererController;
    var BlockRenderer = (function () {
        function BlockRenderer(controller, block) {
            this.rendererConfig = {
                mainWidth: 49,
                mainHeight: 79,
                mainRounding: 5,
                connectorSpacing: 20,
            };
            this.sInputs = {};
            this.sOutputs = {};
            this.controller = controller;
            this.block = block;
            this.initSnapCompnents();
            this.refresh();
        }
        BlockRenderer.prototype.initSnapCompnents = function () {
            var _this = this;
            this.sMainGroup = this.controller.snapPaper.group();
            this.sMainGroup.attr({
                transform: "T" + [this.block.x, this.block.y]
            });
            this.sMainSquare = this.controller.snapPaper.rect(0, 0, this.rendererConfig.mainWidth, this.rendererConfig.mainHeight, this.rendererConfig.mainRounding, this.rendererConfig.mainRounding);
            this.sMainSquare.attr({
                fill: "#ccc",
                stroke: "#000",
                strokeWidth: 2,
                cursor: "move"
            });
            this.sMainGroup.add(this.sMainSquare);
            var displayName = this.block.rendererGetDisplayName();
            var materialIcon = false;
            if (displayName.indexOf("[MI]") == 0) {
                materialIcon = true;
                displayName = displayName.substr(4);
            }
            this.sTextBlockType = this.controller.snapPaper.text(this.rendererConfig.mainWidth / 2, this.rendererConfig.mainHeight / 2, displayName);
            if (materialIcon) {
                this.sTextBlockType.addClass("material-icons");
            }
            else {
                this.sTextBlockType.attr({
                    fontFamily: 'Roboto, sans-serif',
                    fontWeight: 800
                });
            }
            this.sTextBlockType.attr({
                textAnchor: 'middle',
                dominantBaseline: 'central',
                pointerEvents: "none"
            });
            this.sMainGroup.add(this.sTextBlockType);
            this.sTextBlockName = this.controller.snapPaper.text(this.rendererConfig.mainWidth / 2, this.rendererConfig.mainHeight / 2 - 20, this.block.id);
            this.sTextBlockName.attr({
                fontFamily: 'sans-serif',
                textAnchor: 'middle',
                dominantBaseline: 'central',
                pointerEvents: "none"
            });
            this.sMainGroup.add(this.sTextBlockName);
            this.refreshConnectors();
            this.sMainSquare.drag(function (dx, dy) {
                var rx = Math.ceil(dx / 10) * 10;
                var ry = Math.ceil(dy / 10) * 10;
                _this.sMainGroup.attr({
                    transform: _this.sMainGroup.data('origTransform') + (_this.sMainGroup.data('origTransform') ? "T" : "t") + [rx, ry]
                });
                _this.refresh();
            }, function (dx, dy) {
                _this.sMainGroup.data('origTransform', _this.sMainGroup.transform().local);
                _this.refresh();
            }, function () {
                _this.refresh();
            });
            this.sDeleteButton = this.controller.snapPaper.text(this.rendererConfig.mainWidth, 0, MaterialIcons.Cancel);
            this.sDeleteButton.addClass("material-icons");
            this.sDeleteButton.attr({
                fill: "red",
                stroke: "white",
                strokeWidth: 2,
                textAnchor: 'middle',
                dominantBaseline: 'central',
                cursor: "hand",
                opacity: 0.3
            });
            this.sMainGroup.add(this.sDeleteButton);
            this.sDeleteButton.click(function () {
                _this.block.remove();
            });
            this.sDeleteButton.hover(function (event) {
                _this.sDeleteButton.attr({
                    opacity: 1
                });
            }, function (event) {
                _this.sDeleteButton.attr({
                    opacity: 0.3
                });
            });
            if (this.block.getConfigProperties().length > 0) {
                this.sConfigButton = this.controller.snapPaper.text(this.rendererConfig.mainWidth - 12, this.rendererConfig.mainHeight - 12, MaterialIcons.Settings);
                this.sConfigButton.addClass("material-icons");
                this.sConfigButton.attr({
                    fill: "gray",
                    textAnchor: 'middle',
                    dominantBaseline: 'central',
                    fontSize: "20px",
                    cursor: "hand",
                    stroke: "silver"
                });
                this.sMainGroup.add(this.sConfigButton);
                this.sConfigButton.click(function () {
                    _this.controller.callOpenConfigCallback(_this.block);
                });
            }
            if (this.block.visualType == "switch" || this.block.visualType == "pushButton") {
                var sw = (this.block.visualType == "switch");
                this.sTextBlockType.attr({
                    cursor: "hand",
                    pointerEvents: "auto",
                    fill: "red"
                });
                this.sTextBlockType.mousedown(function (event) {
                    if (sw) {
                        var oldValue = _this.block["value"];
                        BlockoCore_1.BlockoCore.Controller.getInstance().setDigitalValue(_this.block.hwId, !oldValue);
                    }
                    else {
                        BlockoCore_1.BlockoCore.Controller.getInstance().setDigitalValue(_this.block.hwId, true);
                    }
                });
                this.sTextBlockType.mouseup(function (event) {
                    if (!sw) {
                        BlockoCore_1.BlockoCore.Controller.getInstance().setDigitalValue(_this.block.hwId, false);
                    }
                });
            }
            else if (this.block.visualType == "analogInput") {
                this.sTextBlockType.attr({
                    cursor: "ns-resize",
                    pointerEvents: "auto",
                    fill: "red",
                    fontFamily: 'Roboto, sans-serif',
                    fontWeight: 800
                });
                this.sTextBlockType.removeClass("material-icons");
                var currentValue = 0;
                var newValue = 0;
                this.sTextBlockType.attr({
                    text: newValue.toFixed(1)
                });
                this.sTextBlockType.drag(function (dx, dy) {
                    newValue = currentValue + -0.1 * dy;
                    _this.sTextBlockType.attr({
                        text: newValue.toFixed(1)
                    });
                    BlockoCore_1.BlockoCore.Controller.getInstance().setAnalogValue(_this.block.hwId, newValue);
                }, function (dx, dy) {
                    currentValue = newValue;
                }, function () {
                });
            }
        };
        BlockRenderer.prototype.refreshConnectors = function () {
            var _this = this;
            var inputConnectors = this.block.getInputConnectors();
            var inputConnectorsCount = inputConnectors.length;
            var inputConnectorsY = this.rendererConfig.mainHeight / 2 - ((inputConnectorsCount - 1) * this.rendererConfig.connectorSpacing) / 2;
            var inputToDelete = Object.keys(this.sInputs);
            inputConnectors.forEach(function (connector) {
                if (_this.sInputs[connector.name]) {
                    _this.sInputs[connector.name].setY(inputConnectorsY);
                }
                else {
                    _this.sInputs[connector.name] = new ConnectorRenderer(0, inputConnectorsY, _this.controller, _this.sMainGroup, connector);
                }
                var i = inputToDelete.indexOf(connector.name);
                if (i > -1) {
                    inputToDelete.splice(i, 1);
                }
                inputConnectorsY += _this.rendererConfig.connectorSpacing;
            });
            inputToDelete.forEach(function (name) {
                _this.sInputs[name].destroy();
                delete _this.sInputs[name];
            });
            var outputConnectors = this.block.getOutputConnectors();
            var outputConnectorsCount = outputConnectors.length;
            var outputConnectorsY = this.rendererConfig.mainHeight / 2 - ((outputConnectorsCount - 1) * this.rendererConfig.connectorSpacing) / 2;
            var outputToDelete = Object.keys(this.sOutputs);
            outputConnectors.forEach(function (connector) {
                if (_this.sOutputs[connector.name]) {
                    _this.sOutputs[connector.name].setY(outputConnectorsY);
                }
                else {
                    _this.sOutputs[connector.name] = new ConnectorRenderer(_this.rendererConfig.mainWidth, outputConnectorsY, _this.controller, _this.sMainGroup, connector);
                }
                var i = outputToDelete.indexOf(connector.name);
                if (i > -1) {
                    outputToDelete.splice(i, 1);
                }
                outputConnectorsY += _this.rendererConfig.connectorSpacing;
            });
            outputToDelete.forEach(function (name) {
                _this.sOutputs[name].destroy();
                delete _this.sOutputs[name];
            });
        };
        BlockRenderer.prototype.refresh = function () {
            this.refreshConnectors();
            this.block.x = this.sMainGroup.transform().globalMatrix["e"];
            this.block.y = this.sMainGroup.transform().globalMatrix["f"];
            for (var key in this.sInputs) {
                if (this.sInputs.hasOwnProperty(key)) {
                    var renderer = this.sInputs[key];
                    renderer.refresh();
                }
            }
            for (var key in this.sOutputs) {
                if (this.sOutputs.hasOwnProperty(key)) {
                    var renderer = this.sOutputs[key];
                    renderer.refresh();
                }
            }
            this.sMainSquare.attr({
                fill: this.block.rendererGetBlockBackgroundColor()
            });
            if (this.block.visualType != "analogInput") {
                var displayName = this.block.rendererGetDisplayName();
                if (displayName.indexOf("[MI]") == 0) {
                    displayName = displayName.substr(4);
                }
                this.sTextBlockType.attr({
                    text: displayName
                });
            }
        };
        BlockRenderer.prototype.destroy = function () {
            if (this.sMainGroup)
                this.sMainGroup.remove();
        };
        BlockRenderer.prototype.getConnectorPosition = function (name) {
            if (this.sInputs[name]) {
                return this.sInputs[name].getPosition();
            }
            else if (this.sOutputs[name]) {
                return this.sOutputs[name].getPosition();
            }
            return new Point(0, 0);
        };
        return BlockRenderer;
    })();
    BlockoSnapRenderer.BlockRenderer = BlockRenderer;
    var ConnectorRenderer = (function () {
        function ConnectorRenderer(x, y, controller, sMainGroup, connector) {
            this.rendererConfig = {
                connectorSize: 10
            };
            this.x = x;
            this.y = y;
            this.controller = controller;
            this.sMainGroup = sMainGroup;
            this.connector = connector;
            this.initSnapCompnents();
            this.refresh();
        }
        ConnectorRenderer.prototype.getPosition = function () {
            var mainX = this.sMainGroup.transform().globalMatrix["e"];
            var mainY = this.sMainGroup.transform().globalMatrix["f"];
            return new Point(mainX + this.x, mainY + this.y);
        };
        ConnectorRenderer.prototype.setY = function (y) {
            this.y = y;
            if (!this.connector.isAnalog()) {
                this.sConnectorObject.attr({
                    y: this.y - (this.rendererConfig.connectorSize / 2)
                });
            }
            else {
                this.sConnectorObject.attr({
                    cy: this.y
                });
            }
        };
        ConnectorRenderer.prototype.initSnapCompnents = function () {
            var _this = this;
            if (!this.connector.isAnalog()) {
                this.sConnectorObject = this.controller.snapPaper.rect(this.x - (this.rendererConfig.connectorSize / 2), this.y - (this.rendererConfig.connectorSize / 2), this.rendererConfig.connectorSize, this.rendererConfig.connectorSize, 2, 2);
            }
            else {
                this.sConnectorObject = this.controller.snapPaper.circle(this.x, this.y, this.rendererConfig.connectorSize / 2);
            }
            this.sConnectorObject.attr({
                fill: this.connector.isAnalog() ? "green" : "blue",
                stroke: "#000",
                strokeWidth: 2,
                cursor: "crosshair"
            });
            this.sConnectorObject.addClass(ConnectorRenderer.idClass);
            this.sConnectorObject.data(ConnectorRenderer.idClass, this);
            this.sMainGroup.add(this.sConnectorObject);
            var startX = 0;
            var startY = 0;
            this.sConnectorObject.drag(function (dx, dy) {
                _this.controller.tempConnectionLineMove(_this, new Point(dx, dy));
            }, function (x, y) {
                _this.controller.tempConnectionLineStart(_this, new Point(x, y));
            }, function () {
                _this.controller.tempConnectionLineEnd(_this);
            });
        };
        ConnectorRenderer.prototype.destroy = function () {
            if (this.sConnectorObject)
                this.sConnectorObject.remove();
        };
        ConnectorRenderer.prototype.refresh = function () {
            if (!this.connector.isAnalog()) {
                this.sConnectorObject.attr({
                    fill: (this.connector.value == 0) ? "blue" : "red"
                });
            }
            this.connector.connections.forEach(function (connection) {
                connection.renderer.refresh();
            });
        };
        ConnectorRenderer.idClass = "connectorRenderer";
        return ConnectorRenderer;
    })();
    BlockoSnapRenderer.ConnectorRenderer = ConnectorRenderer;
    var ConnectionRenderer = (function () {
        function ConnectionRenderer(controller, connection) {
            this.rendererConfig = {};
            this.controller = controller;
            this.connection = connection;
            this.initSnapCompnents();
            this.refresh();
        }
        ConnectionRenderer.prototype.initSnapCompnents = function () {
            var _this = this;
            this.sLine = this.controller.snapPaper.line(0, 0, 10, 10);
            this.sLine.attr({
                stroke: "#000",
                strokeWidth: 2,
                pointerEvents: "none"
            });
            this.sDeleteButton = this.controller.snapPaper.text(100, 100, MaterialIcons.Cancel);
            this.sDeleteButton.addClass("material-icons");
            this.sDeleteButton.attr({
                fill: "red",
                stroke: "white",
                strokeWidth: 2,
                textAnchor: 'middle',
                dominantBaseline: 'central',
                cursor: "hand",
                opacity: 0.3
            });
            this.sDeleteButton.click(function () {
                _this.connection.disconnect();
            });
            this.sDeleteButton.hover(function (event) {
                _this.sDeleteButton.attr({
                    opacity: 1
                });
            }, function (event) {
                _this.sDeleteButton.attr({
                    opacity: 0.3
                });
            });
        };
        ConnectionRenderer.prototype.destroy = function () {
            if (this.sLine)
                this.sLine.remove();
            if (this.sDeleteButton)
                this.sDeleteButton.remove();
        };
        ConnectionRenderer.prototype.refresh = function () {
            var posA = this.connection.connectorA.block.renderer.getConnectorPosition(this.connection.connectorA.name);
            var posB = this.connection.connectorB.block.renderer.getConnectorPosition(this.connection.connectorB.name);
            var valueConnector = this.connection.getOutputConnector();
            this.sLine.attr({
                x1: posA.x,
                y1: posA.y,
                x2: posB.x,
                y2: posB.y,
                stroke: valueConnector.isAnalog() ? "green" : (valueConnector.value == 0) ? "blue" : "red"
            });
            this.sDeleteButton.attr({
                x: (posA.x + posB.x) / 2,
                y: (posA.y + posB.y) / 2
            });
        };
        return ConnectionRenderer;
    })();
    BlockoSnapRenderer.ConnectionRenderer = ConnectionRenderer;
})(BlockoSnapRenderer = exports.BlockoSnapRenderer || (exports.BlockoSnapRenderer = {}));
