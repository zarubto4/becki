/// <reference path="./typings/tsd.d.ts" />

import {BlockoCore} from "./BlockoCore";

export module BlockoSnapRenderer {
	
	// Defines for unicode codes of Material Icons
	var MaterialIcons = {
		RemoveCircle: "\uE15C",
		Cancel: "\uE5C9",
		Settings: "\uE8B8",
	}
	
	export class Point {
		public x:number;
		public y:number;
		public constructor(x: number, y:number) {
			this.x = x;
			this.y = y;
		}
		public plus(p:Point):Point {
			return new Point(this.x + p.x, this.y + p.y);
		}
		public minus(p:Point):Point {
			return new Point(this.x - p.x, this.y - p.y);
		}
	}
	
	export class RendererController {
		public snapPaper: Snap.Paper;
		public editorSvgElement: HTMLElement;
		public editorMainElement: HTMLElement;
		
		public sTempConnectionLine: Snap.Element;
		
		private rendererConfig = {
			connectionLineColorSuccess: "black",
			connectionLineColorFail: "#ccc"
		};
		
		public constructor(editorElement:HTMLElement) {

			this.editorMainElement = editorElement;

			this.editorMainElement.className += " blocko-editor__main";
			this.editorMainElement.style.position = "relative";
			this.editorMainElement.style.overflow = "auto";

			this.editorSvgElement = <HTMLElement><any>document.createElementNS("http://www.w3.org/2000/svg", "svg");
			this.editorSvgElement.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
			this.editorSvgElement.setAttributeNS(null, "class", "blocko-editor__svg");
			this.editorMainElement.appendChild(this.editorSvgElement);

			this.editorSvgElement.style.minHeight = "100%";
			this.editorSvgElement.style.minWidth = "100%";
			this.editorSvgElement.style.backgroundImage = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKAQMAAAC3/F3+AAAABlBMVEUAAAAAAAClZ7nPAAAAAnRSTlMAQABPjKgAAAALSURBVAjXY8AHHAAAXgBBoiU/swAAAABJRU5ErkJggg==)";

			this.snapPaper = Snap(<SVGElement><any>this.editorSvgElement);

			this.initSnapCompnents();
		}
		
		public initSnapCompnents() {
			
			this.sTempConnectionLine = this.snapPaper.line(0, 0, 0, 0);
			this.sTempConnectionLine.attr({
				stroke: "#000",
				strokeWidth: 2,
				pointerEvents: "none",
				visibility: "hidden"
			});
		}

		private openConfigCallback:(block: BlockoCore.Block) => void = null;
		public registerOpenConfigCallback(callback: (block: BlockoCore.Block) => void):void {
			this.openConfigCallback = callback;
		}

		public callOpenConfigCallback(block:BlockoCore.Block):void {
			if (this.openConfigCallback) {
				this.openConfigCallback(block);
			}
		}
		
		private cumulativeOffset(element:HTMLElement):{top:number, left:number} {
			var top = 0, left = 0;
			do {
				top += element.offsetTop  || 0;
				left += element.offsetLeft || 0;
				element = <HTMLElement><any>element.offsetParent;
			} while(element);
		
			return {
				top: top,
				left: left
			};
		}
		
		public getPaperAbsolutePosition() {
			return this.cumulativeOffset(this.snapPaper.node);
		}
		
		public globalPointToLocal(point:Point):Point {
			var pos:{top:number, left:number} = this.getPaperAbsolutePosition();
			return new Point(point.x - pos.left, point.y - pos.top);
		}
		
		public localPointToGlobal(point:Point):Point {
			var pos:{top:number, left:number} = this.getPaperAbsolutePosition();
			return new Point(point.x + pos.left, point.y + pos.top);
		}
		
		
		
		// sTempConnectionLine working
		private currentConnectorRenderer: ConnectorRenderer = null;
		
		private currentStartPoint: Point;
		private currentLastPoint: Point;
		
		public tempConnectionLineStart(connectorRenderer: ConnectorRenderer, point: Point) {
			
			if (!connectorRenderer.connector.haveFreeSpace()) return; // no start if not free space
			
			this.currentConnectorRenderer = connectorRenderer;
			this.currentStartPoint = this.globalPointToLocal(point);
			this.currentLastPoint = this.currentStartPoint;
			
			var conPos:Point = connectorRenderer.getPosition();
			
			this.snapPaper.add(this.sTempConnectionLine); // move to front
			
			this.sTempConnectionLine.attr({
				x1: conPos.x,
				y1: conPos.y,
				x2: this.currentStartPoint.x,
				y2: this.currentStartPoint.y,
				visibility: "visible",
				stroke: this.rendererConfig.connectionLineColorFail
			});
		}
		
		public tempConnectionLineMove(connectorRenderer: ConnectorRenderer, diffPoint: Point) {
			if (this.currentConnectorRenderer != connectorRenderer) {
				this.sTempConnectionLine.attr({
					visibility: "hidden"
				});
				this.currentConnectorRenderer = null;
				return;
			}
			
			var nowPoint:Point = this.currentStartPoint.plus(diffPoint);
			var nowPointGlobal:Point = this.localPointToGlobal(nowPoint);
			
			this.currentLastPoint = nowPoint;
			
			var element:Snap.Element = Snap.getElementByPoint(nowPointGlobal.x, nowPointGlobal.y);
			
			var canConnect: boolean = false;
			
			try {
				if (element && element.hasClass(ConnectorRenderer.idClass)) {
					var connector:ConnectorRenderer = element.data(ConnectorRenderer.idClass);
					canConnect = this.currentConnectorRenderer.connector.canConnect(connector.connector);
				}
			} catch (error) {
				// this is need for bug in hasClass in snapsvg
			}
			
			this.sTempConnectionLine.attr({
				x2: nowPoint.x,
				y2: nowPoint.y,
				stroke: canConnect?this.rendererConfig.connectionLineColorSuccess:this.rendererConfig.connectionLineColorFail
			});
		}
		
		public tempConnectionLineEnd(connectorRenderer: ConnectorRenderer) {
			if (this.currentConnectorRenderer != connectorRenderer) {
				this.sTempConnectionLine.attr({
					visibility: "hidden"
				});
				this.currentConnectorRenderer = null;
				return;
			}
			
			var nowPoint:Point = this.currentLastPoint;
			var nowPointGlobal:Point = this.localPointToGlobal(nowPoint);
			
			var element:Snap.Element = Snap.getElementByPoint(nowPointGlobal.x, nowPointGlobal.y);
			
			var canConnect: boolean = false;
			
			try {
				if (element && typeof element["hasClass"] == "function" && element.hasClass(ConnectorRenderer.idClass)) {
					var connector:ConnectorRenderer = element.data(ConnectorRenderer.idClass);
					canConnect = this.currentConnectorRenderer.connector.canConnect(connector.connector);
					
					if (canConnect) {
						this.currentConnectorRenderer.connector.connect(connector.connector);
					}
				}
			} catch (error) {
				// this is need for bug in hasClass in snapsvg
			}
			
			this.sTempConnectionLine.attr({
				visibility: "hidden"
			});
			this.currentConnectorRenderer = null;
			
		}
		
	}
	
	export class BlockRenderer implements BlockoCore.IBlockRenderer {
		
		private controller: RendererController;
		private block: BlockoCore.Block;
		
		private rendererConfig = {
			mainWidth: 49,
			mainHeight: 79,
			mainRounding: 5,
			connectorSpacing: 20,
		};
		
		private sMainGroup: Snap.Element;
		private sMainSquare: Snap.Element;
		private sTextBlockType: Snap.Element;
		private sTextBlockName: Snap.Element;
		
		private sButton: Snap.Element;
		private sDeleteButton: Snap.Element;
		private sConfigButton: Snap.Element;
		
		private sInputs: {[name:string]: ConnectorRenderer} = {};
		private sOutputs: {[name:string]: ConnectorRenderer} = {};
		
		public constructor(controller: RendererController, block: BlockoCore.Block) {
			this.controller = controller;
			this.block = block;
			this.initSnapCompnents();
			this.refresh();
		}
		
		public initSnapCompnents() {
			
			this.sMainGroup = this.controller.snapPaper.group();
			this.sMainGroup.attr({
				transform: "T" + [this.block.x, this.block.y]
			});
			
			this.sMainSquare = this.controller.snapPaper.rect(0, 0, this.rendererConfig.mainWidth, this.rendererConfig.mainHeight, this.rendererConfig.mainRounding, this.rendererConfig.mainRounding);
			this.sMainSquare.attr({
				fill: "#ccc",
				stroke: "#000",
				strokeWidth: 2,
				cursor: "move"
			});
			this.sMainGroup.add(this.sMainSquare);
			
			var displayName: string = this.block.rendererGetDisplayName();
			var materialIcon: boolean = false;
			if (displayName.indexOf("[MI]") == 0) { //start with
				materialIcon = true;
				displayName = displayName.substr(4);
			}
			
			this.sTextBlockType = this.controller.snapPaper.text(this.rendererConfig.mainWidth/2, this.rendererConfig.mainHeight/2, displayName);
			if (materialIcon) {
				this.sTextBlockType.addClass("material-icons");
			} else {
				this.sTextBlockType.attr({
					fontFamily: 'Roboto, sans-serif',
					fontWeight: 800
				});
			}
			this.sTextBlockType.attr({
				textAnchor: 'middle',
				dominantBaseline: 'central',
				pointerEvents: "none"
			});
			this.sMainGroup.add(this.sTextBlockType);
			
			this.sTextBlockName = this.controller.snapPaper.text(this.rendererConfig.mainWidth/2, this.rendererConfig.mainHeight/2 - 20, this.block.id);
			this.sTextBlockName.attr({
				fontFamily: 'sans-serif',
				textAnchor: 'middle',
				dominantBaseline: 'central',
				pointerEvents: "none"
			});
			this.sMainGroup.add(this.sTextBlockName);
			
			this.refreshConnectors();
			
			this.sMainSquare.drag((dx: number, dy: number) => { //move
				var rx = Math.ceil(dx/10)*10;
				var ry = Math.ceil(dy/10)*10;
				this.sMainGroup.attr({
					transform: this.sMainGroup.data('origTransform') + (this.sMainGroup.data('origTransform') ? "T" : "t") + [rx, ry]
				});
				this.refresh();
			},(dx: number, dy: number) => { //start
				this.sMainGroup.data('origTransform', this.sMainGroup.transform().local);
				this.refresh();
			},() => { // end
				this.refresh();
			});
			
			this.sDeleteButton = this.controller.snapPaper.text(this.rendererConfig.mainWidth, 0, MaterialIcons.Cancel);
			this.sDeleteButton.addClass("material-icons");
			this.sDeleteButton.attr({
				fill: "red",
				stroke: "white",
				strokeWidth: 2,
				textAnchor: 'middle',
				dominantBaseline: 'central',
				cursor: "hand",
				opacity: 0.3
			});
			this.sMainGroup.add(this.sDeleteButton);
			
			this.sDeleteButton.click(() => {
				this.block.remove();
			});
			this.sDeleteButton.hover((event: MouseEvent) => {
				this.sDeleteButton.attr({
					opacity: 1
				});
			}, (event: MouseEvent) => {
				this.sDeleteButton.attr({
					opacity: 0.3
				});
			});
			
			if (this.block.getConfigProperties().length > 0) {
				
				this.sConfigButton = this.controller.snapPaper.text(this.rendererConfig.mainWidth - 12, this.rendererConfig.mainHeight - 12, MaterialIcons.Settings);
				this.sConfigButton.addClass("material-icons");
				this.sConfigButton.attr({
					fill: "gray",
					textAnchor: 'middle',
					dominantBaseline: 'central',
					fontSize: "20px",
					cursor: "hand",
					stroke: "silver"
				});
				this.sMainGroup.add(this.sConfigButton);
				
				this.sConfigButton.click(() => {
					this.controller.callOpenConfigCallback(this.block);
				});
				
			}
			
			if (this.block.visualType == "switch" || this.block.visualType == "pushButton") {
				
				var sw: boolean = (this.block.visualType == "switch");
				/*
				this.sButton = this.controller.snapPaper.rect(5, this.rendererConfig.mainHeight - 15, this.rendererConfig.mainWidth - 10, 10, 5, 5);
				this.sButton.attr({
					fill: "gray",
					stroke: "#000",
					strokeWidth: 2,
					cursor: "hand"
				});
				this.sMainGroup.add(this.sButton);*/
				
				this.sTextBlockType.attr({
					cursor: "hand",
					pointerEvents: "auto",
					fill: "red"
				});
				
				this.sTextBlockType.mousedown((event: MouseEvent) => {
					
					if (sw) {
						var oldValue: boolean = this.block["value"];
						BlockoCore.Controller.getInstance().setDigitalValue(this.block.hwId, !oldValue);
					} else {
						BlockoCore.Controller.getInstance().setDigitalValue(this.block.hwId, true);
					}
					
				});
				
				this.sTextBlockType.mouseup((event: MouseEvent) => {
					if (!sw) {
						BlockoCore.Controller.getInstance().setDigitalValue(this.block.hwId, false);
					}
				});
			
			} else if (this.block.visualType == "analogInput") {
				
				this.sTextBlockType.attr({
					cursor: "ns-resize",
					pointerEvents: "auto",
					fill: "red",
					fontFamily: 'Roboto, sans-serif',
					fontWeight: 800
				});
				
				this.sTextBlockType.removeClass("material-icons");
				
				var currentValue = 0;
				var newValue = 0;
				
				this.sTextBlockType.attr({
					text: newValue.toFixed(1)
				});
				
				this.sTextBlockType.drag((dx: number, dy: number) => { //move
						
						newValue = currentValue + -0.1*dy;
						
						this.sTextBlockType.attr({
							text: newValue.toFixed(1)
						});
						
						BlockoCore.Controller.getInstance().setAnalogValue(this.block.hwId, newValue);
						
					},(dx: number, dy: number) => { //start
						
						currentValue = newValue;
						
					},() => { // end
				});
				
			}
			
		}
		
		public refreshConnectors() {
			
			var inputConnectors = this.block.getInputConnectors();
			var inputConnectorsCount = inputConnectors.length;
			var inputConnectorsY = this.rendererConfig.mainHeight/2 - ((inputConnectorsCount-1)*this.rendererConfig.connectorSpacing)/2;
			var inputToDelete = Object.keys(this.sInputs);
			inputConnectors.forEach((connector:BlockoCore.Connector) => {
				
				if (this.sInputs[connector.name]) {
					this.sInputs[connector.name].setY(inputConnectorsY);
				} else {
					this.sInputs[connector.name] = new ConnectorRenderer(0, inputConnectorsY, this.controller, this.sMainGroup, connector);
				}
				
				var i = inputToDelete.indexOf(connector.name);
				if (i > -1) {
					inputToDelete.splice(i, 1);
				}
				
				inputConnectorsY += this.rendererConfig.connectorSpacing;
			});
			
			inputToDelete.forEach((name:string) => {
				this.sInputs[name].destroy();
				delete this.sInputs[name];
			});
			
			var outputConnectors = this.block.getOutputConnectors();
			var outputConnectorsCount = outputConnectors.length;
			var outputConnectorsY = this.rendererConfig.mainHeight/2 - ((outputConnectorsCount-1)*this.rendererConfig.connectorSpacing)/2;
			var outputToDelete = Object.keys(this.sOutputs);
			outputConnectors.forEach((connector:BlockoCore.Connector) => {
				
				if (this.sOutputs[connector.name]) {
					this.sOutputs[connector.name].setY(outputConnectorsY);
				} else {
					this.sOutputs[connector.name] = new ConnectorRenderer(this.rendererConfig.mainWidth, outputConnectorsY, this.controller, this.sMainGroup, connector);
				}
				
				var i = outputToDelete.indexOf(connector.name);
				if (i > -1) {
					outputToDelete.splice(i, 1);
				}
				
				outputConnectorsY += this.rendererConfig.connectorSpacing;
			});
			
			outputToDelete.forEach((name:string) => {
				this.sOutputs[name].destroy();
				delete this.sOutputs[name];
			});
			
		}
		
		public refresh() {
			
			this.refreshConnectors();
			
			this.block.x = this.sMainGroup.transform().globalMatrix["e"];
			this.block.y = this.sMainGroup.transform().globalMatrix["f"];
			
			for (var key in this.sInputs) {
				if (this.sInputs.hasOwnProperty(key)) {
					var renderer:ConnectorRenderer = this.sInputs[key];
					renderer.refresh();
				}
			}
			
			for (var key in this.sOutputs) {
				if (this.sOutputs.hasOwnProperty(key)) {
					var renderer:ConnectorRenderer = this.sOutputs[key];
					renderer.refresh();
				}
			}
			
			this.sMainSquare.attr({
				fill: this.block.rendererGetBlockBackgroundColor()
			});
			
			if (this.block.visualType != "analogInput") {
				
				var displayName: string = this.block.rendererGetDisplayName();
				if (displayName.indexOf("[MI]") == 0) { //start with
					displayName = displayName.substr(4);
				}
				this.sTextBlockType.attr({
					text: displayName
				});
				
			}
		}
		
		public destroy():void {
			if (this.sMainGroup) this.sMainGroup.remove();
		}
		
		public getConnectorPosition(name:string):Point {
			
			if (this.sInputs[name]) {
				return this.sInputs[name].getPosition();
			} else if (this.sOutputs[name]) {
				return this.sOutputs[name].getPosition();
			}
			
			return new Point(0,0);
		}
		
	}
	
	export class ConnectorRenderer {
		
		public static idClass = "connectorRenderer";
		
		private controller: RendererController;
		private sMainGroup: Snap.Element;
		public connector: BlockoCore.Connector;
		
		private rendererConfig = {
			connectorSize: 10
		};
		
		public x: number;
		public y: number;
		
		private sConnectorObject: Snap.Element;
		
		public constructor(x:number, y:number, controller: RendererController, sMainGroup: Snap.Element, connector: BlockoCore.Connector) {
			this.x = x;
			this.y = y;
			this.controller = controller;
			this.sMainGroup = sMainGroup;
			this.connector = connector;
			this.initSnapCompnents();
			this.refresh();
		}
		
		public getPosition():Point {
			var mainX:number = this.sMainGroup.transform().globalMatrix["e"];
			var mainY:number = this.sMainGroup.transform().globalMatrix["f"];
			return new Point(mainX + this.x, mainY + this.y);
		}
		
		public setY(y:number) {
			this.y = y;
			if (!this.connector.isAnalog()) {
				this.sConnectorObject.attr({
					y: this.y - (this.rendererConfig.connectorSize/2)
				});
			} else {
				this.sConnectorObject.attr({
					cy: this.y
				});
			}
		}
		
		public initSnapCompnents() {
			
			if (!this.connector.isAnalog()) {
				this.sConnectorObject = this.controller.snapPaper.rect(this.x - (this.rendererConfig.connectorSize/2), this.y - (this.rendererConfig.connectorSize/2), this.rendererConfig.connectorSize, this.rendererConfig.connectorSize, 2, 2);
			} else {
				this.sConnectorObject = this.controller.snapPaper.circle(this.x, this.y, this.rendererConfig.connectorSize/2);
			}	
			this.sConnectorObject.attr({
				fill: this.connector.isAnalog()?"green":"blue",
				stroke: "#000",
				strokeWidth: 2,
				cursor: "crosshair"
			});
			this.sConnectorObject.addClass(ConnectorRenderer.idClass);
			this.sConnectorObject.data(ConnectorRenderer.idClass, this);
			this.sMainGroup.add(this.sConnectorObject);
			
			var startX = 0;
			var startY = 0;
			
			this.sConnectorObject.drag((dx: number, dy: number) => { //move
				this.controller.tempConnectionLineMove(this, new Point(dx, dy));
			},(x: number, y: number) => { //start
				this.controller.tempConnectionLineStart(this, new Point(x, y));
			},() => { // end
				this.controller.tempConnectionLineEnd(this);
			});
			
		}
		
		public destroy() {
			if (this.sConnectorObject) this.sConnectorObject.remove();
		}
		
		public refresh() {
			
			if (!this.connector.isAnalog()) {
				this.sConnectorObject.attr({
					fill: (this.connector.value == 0)?"blue":"red"
				});
			}
			
			this.connector.connections.forEach((connection:BlockoCore.Connection) => {
				connection.renderer.refresh();
			});
		}
		
	}
	
	export class ConnectionRenderer implements BlockoCore.IConnectionRenderer {
		
		private controller: RendererController;
		private connection: BlockoCore.Connection;
		
		private rendererConfig = {
		};
		
		private sLine: Snap.Element;
		private sDeleteButton: Snap.Element;
		
		public constructor(controller: RendererController, connection: BlockoCore.Connection) {
			this.controller = controller;
			this.connection = connection;
			this.initSnapCompnents();
			this.refresh();
		}
		
		public initSnapCompnents() {
			this.sLine = this.controller.snapPaper.line(0, 0, 10, 10);
			this.sLine.attr({
				stroke: "#000",
				strokeWidth: 2,
				pointerEvents: "none"
			});
			
			this.sDeleteButton = this.controller.snapPaper.text(100, 100, MaterialIcons.Cancel);
			this.sDeleteButton.addClass("material-icons");
			this.sDeleteButton.attr({
				fill: "red",
				stroke: "white",
				strokeWidth: 2,
				textAnchor: 'middle',
				dominantBaseline: 'central',
				cursor: "hand",
				opacity: 0.3
			});
			
			this.sDeleteButton.click(() => {
				this.connection.disconnect();
			});
			
			this.sDeleteButton.hover((event: MouseEvent) => {
				this.sDeleteButton.attr({
					opacity: 1
				});
			}, (event: MouseEvent) => {
				this.sDeleteButton.attr({
					opacity: 0.3
				});
			});
			
			
		}
		
		public destroy() {
			if (this.sLine) this.sLine.remove();
			if (this.sDeleteButton) this.sDeleteButton.remove();
		}
		
		public refresh() {
			
			var posA:{x:number, y:number} = this.connection.connectorA.block.renderer.getConnectorPosition(this.connection.connectorA.name);
			var posB:{x:number, y:number} = this.connection.connectorB.block.renderer.getConnectorPosition(this.connection.connectorB.name);
			
			var valueConnector: BlockoCore.Connector = this.connection.getOutputConnector();
			
			this.sLine.attr({
				x1: posA.x,
				y1: posA.y,
				x2: posB.x,
				y2: posB.y,
				stroke: valueConnector.isAnalog()?"green":(valueConnector.value == 0)?"blue":"red"
			});
			
			this.sDeleteButton.attr({
				x: (posA.x + posB.x) / 2,
				y: (posA.y + posB.y) / 2
			})
			
		}
	}
	
}