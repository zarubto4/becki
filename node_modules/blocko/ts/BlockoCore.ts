

export module BlockoCore {

	// this is handle for class
	export interface BlockClass {
		new (id: string);
	}
	
	export class BlockRegistration {
		public blockClass: BlockClass;
		public type: string;
		public visualType: string;
		public displayName: string;
		constructor(blockClass: BlockClass, type: string, visualType: string, displayName: string) {
			this.blockClass = blockClass;
			this.type = type;
			this.visualType = visualType;
			this.displayName = displayName;
		}
	}
	
	// Main controller
	export class Controller {
		
		// Singleton
		private static _instance:Controller = new Controller();
		public static getInstance():Controller {
			return Controller._instance;
		}
		
		blocksRegister: Array<BlockRegistration>;
		
		// Blocks storage
		blocks: Array<Block>;
		connections: Array<Connection>;
		
		public constructor() {
			this.blocks = [];
			this.connections = [];
			this.blocksRegister = [];
		}

		public registerBlocks(blocksClass:Array<BlockClass>):void {
			blocksClass.forEach((bc:BlockClass) => {
				this.registerBlock(bc);
			});
		}
		
		public registerBlock(blockClass:BlockClass):void {
			var b:Block = new blockClass("register");
			var blockRegistration: BlockRegistration = new BlockRegistration(blockClass, b.type, b.visualType, b.rendererGetDisplayName());
			this.blocksRegister.push(blockRegistration);
		}
		
		public getBlockClassByVisutalType(visualType: string):BlockClass {
			var blockClass: BlockClass = null;
			this.blocksRegister.forEach((blockRegistration: BlockRegistration) => {
				if (blockRegistration.visualType == visualType) {
					blockClass = blockRegistration.blockClass; 
				}
			});
			return blockClass;
		}
		
		public addBlock(block:Block) {
			
			if (typeof block["registerDigitalValueChangeCallback"] == "function") {
				var blockDo: IDigitalOutputBlock = <IDigitalOutputBlock><any>block;
				blockDo.registerDigitalValueChangeCallback((block: Block, value: boolean) => this.blockDigitalValueChangeCallback(block, value));
			}
			
			if (typeof block["registerAnalogValueChangeCallback"] == "function") {
				var blockAo: IAnalogOutputBlock = <IAnalogOutputBlock><any>block;
				blockAo.registerAnalogValueChangeCallback((block: Block, value: number) => this.blockAnalogValueChangeCallback(block, value));
			}
			
			if (this.factoryBlockRendererCallback) {
				block.renderer = this.factoryBlockRendererCallback(block);
			}
			
			block.inputsChanged(); // TODO: only test for defaults!
			
			this.blocks.push(block);
		}
		
		public _addConnection(connection: Connection) {
			if (this.factoryConnectionRendererCallback) {
				connection.renderer = this.factoryConnectionRendererCallback(connection);
			}
			
			this.connections.push(connection);
		}
		
		public _removeConnection(connection: Connection) {
			var index = this.connections.indexOf(connection);
			if (index > -1) {
				this.connections.splice(index, 1);
			}
		}
		
		public _removeBlock(block: Block) {
			var index = this.blocks.indexOf(block);
			if (index > -1) {
				this.blocks.splice(index, 1);
			}
		}
		
		public removeAllBlocks():void {
			var toDelete: Array<Block> = this.blocks.slice(0);
			
			toDelete.forEach((block: Block) => {
				block.remove();
			});
			
			this.blockIndex = 0; // reset block index
		}
		
		public getBlockById(id: string):Block {
			var block: Block = null;
			this.blocks.forEach((b:Block) => {
				if (b.id == id) {
					block = b;
				}
			});
			return block;
		}
		
		
		private blockIndex = 0;
		public getFreeBlockId():string {
			var id:string = "";
			do {
				this.blockIndex++;
				id = "b"+this.blockIndex;
			} while (this.getBlockById(id) != null);
			return id;
		}
		
		private factoryBlockRendererCallback:(block: Block) => IBlockRenderer = null;
		public registerFactoryBlockRendererCallback(callback: (block: Block) => IBlockRenderer):void {
			this.factoryBlockRendererCallback = callback;
		}
		
		private factoryConnectionRendererCallback:(connection: Connection) => IConnectionRenderer = null;
		public registerFactoryConnectionRendererCallback(callback: (connection: Connection) => IConnectionRenderer):void {
			this.factoryConnectionRendererCallback = callback;
		}
		
		private digitalValueChangeCallback:(hwId: string, value: boolean) => void = null;
		public registerDigitalValueChangeCallback(callback: (hwId: string, value: boolean) => void):void {
			this.digitalValueChangeCallback = callback;
		}
		
		private analogValueChangeCallback:(hwId: string, value: number) => void = null;
		public registerAnalogValueChangeCallback(callback: (hwId: string, value: number) => void):void {
			this.analogValueChangeCallback = callback;
		}
		
		private blockDigitalValueChangeCallback(block: Block, value: boolean):void {
			if (this.digitalValueChangeCallback) {
				this.digitalValueChangeCallback(block.hwId, value);
			}
		}
		
		private blockAnalogValueChangeCallback(block: Block, value: number):void {
			if (this.analogValueChangeCallback) {
				this.analogValueChangeCallback(block.hwId, value);
			}
		}
		
		public setDigitalValue(hwId: string, value: boolean):void {
			this.blocks.forEach(block => {
				if (block.hwId == hwId) {
					if (typeof block["setDigitalValue"] == "function") {
						var di: IDigitalInputBlock = <IDigitalInputBlock><any>block;
						di.setDigitalValue(value);
					}
				}
			});
		}
		
		public setAnalogValue(hwId: string, value: number):void {
			this.blocks.forEach(block => {
				if (block.hwId == hwId) {
					if (typeof block["setAnalogValue"] == "function") {
						var di: IAnalogInputBlock = <IAnalogInputBlock><any>block;
						di.setAnalogValue(value);
					}
				}
			});
		}
		
		public getDigitalInputHwIds():Array<string> {
			var ret:Array<string> = [];
			this.blocks.forEach(block => {
				if (block.hwId) {
					if (typeof block["setDigitalValue"] == "function") {
						ret.push(block.hwId);
					}
				}
			});
			return ret;
		}
		
		public getAnalogInputHwIds():Array<string> {
			var ret:Array<string> = [];
			this.blocks.forEach(block => {
				if (block.hwId) {
					if (typeof block["setAnalogValue"] == "function") {
						ret.push(block.hwId);
					}
				}
			});
			return ret;
		}
		
		// Saving and loading
		
		public getDataJson():string {
			var json:any = {}
			json["blocks"] = {};
			
			this.blocks.forEach((block:Block) => {
				var blockJson:any = {};
				blockJson["type"] = block.type;
				blockJson["visualType"] = block.visualType;
				blockJson["hwId"] = block.hwId;
				
				blockJson["config"] = block.getConfigData();
				
				blockJson["editor"] = {};
				blockJson["editor"]["x"] = block.x;
				blockJson["editor"]["y"] = block.y;
				
				
				blockJson["outputs"] = {};
				var outputs:Array<Connector> =  block.getOutputConnectors();
				outputs.forEach((connector:Connector) => {
					var connectionsJson:Array<any> = [];
					
					connector.connections.forEach((connection:Connection) =>Â {
						var otherConnector:Connector = connection.getOtherConnector(connector);
						connectionsJson.push({
							"block": otherConnector.block.id,
							"connector": otherConnector.name
						})
					});
					
					blockJson["outputs"][connector.name] = connectionsJson;
				});
				
				json["blocks"][block.id] = blockJson;
			});
			
			return JSON.stringify(json);
		}
		
		public setDataJson(jsonString: string):string {
			
			try {
				// Begin of load
				var json: any = JSON.parse(jsonString);
				
				//TODO: make it better!
				
				if (json && json["blocks"]) {
					this.removeAllBlocks();
					
					var blocks:any = json["blocks"];
					
					// first pass - init blocks
					for (var id in blocks) {
						if (blocks.hasOwnProperty(id)) {
							var block:any = blocks[id];
							
							var bc:BlockClass = this.getBlockClassByVisutalType(block["visualType"]);
							
							var blockObj: Block = new bc(id);
							blockObj.hwId = block["hwId"];
							
							blockObj.setConfigData(block["config"]);
							
							blockObj.x = block["editor"]["x"];
							blockObj.y = block["editor"]["y"];
							
							this.addBlock(blockObj);
							
						}
					}
					
					// second pass - connecting
					for (var id in blocks) {
						if (blocks.hasOwnProperty(id)) {
							var block:any = blocks[id];
							
							var b1: Block = this.getBlockById(id);
							
							var outputs = block["outputs"];
							for (var outputName in outputs) {
								if (outputs.hasOwnProperty(outputName)) {
									
									var connections: Array<any> = outputs[outputName];
									connections.forEach((connParams: any) => {
										
										var b2name = connParams["block"];
										var inputName = connParams["connector"];
										
										
										var c1: Connector = b1.getOutputConnectorByName(outputName);
										var b2: Block = this.getBlockById(b2name);
										var c2: Connector = b2.getInputConnectorByName(inputName);
										
										c1.connect(c2);
										
									});
									
								}
							}
							
							
						}
					}
					
				}
				// End of load
			} catch (error) {
				this.removeAllBlocks();
				return "ERROR: "+error;
			}
			
			return "OK";
			
		}
	}

	// Contector types
	export enum ConnectorType {DigitalOutput, DigitalInput, DigitalInputOr, DigitalInputAnd, DigitalInputXor, AnalogInput, AnalogOutput/*, Output, Input*/};

	export class Connector {
		public block: Block;
		public name: string;
		public type: ConnectorType;
		public value: number = 0;
		
		public connections: Array<Connection>;
		
		public constructor(block: Block, name: string, type: ConnectorType) {
			this.connections = new Array<Connection>();
			this.block = block;
			this.name = name;
			this.type = type;
		}
		
		public connect(target:Connector):Connection {
			if (this.canConnect(target)) {
				var connection: Connection = new Connection(this, target);
				this.connections.push(connection);
				target.connections.push(connection);
				
				//TODO: think about better solution!
				Controller.getInstance()._addConnection(connection);
				
				// send value when init
				connection.getInputConnector()._inputSetValue(connection.getOutputConnector().value);
				
				return connection;
			}
			return null;
		}
		
		public _removeConnection(connection: Connection) {
			var index = this.connections.indexOf(connection);
			if (index > -1) {
				this.connections.splice(index, 1);
			}
		}
		
		public canConnect(target:Connector):boolean {
			if (this.block == target.block) { // cannot connect same block
				return false;
			}
			
			if (!this.haveFreeSpace() || !target.haveFreeSpace()) { // if dont have free space cannot connect
				return false;
			}
			
			if (this.isInput() && target.isInput()) { // cannot connect two inputs
				return false;
			}
			
			if (this.isOutput() && target.isOutput()) { // cannot connect two outputs
				return false;
			}
			
			if (this.isAnalog() != target.isAnalog()) { // cannot connect digital and analog
				return false;
			}
			
			// TODO: ignorovat stejnou konexi
			
			return true;
		}
		
		public isOutput():boolean {
			return (this.type == ConnectorType.DigitalOutput || this.type == ConnectorType.AnalogOutput);
		}
		
		public isInput():boolean {
			return (this.type == ConnectorType.DigitalInput) || (this.type == ConnectorType.DigitalInputAnd) || (this.type == ConnectorType.DigitalInputOr) || (this.type == ConnectorType.DigitalInputXor) || (this.type == ConnectorType.AnalogInput) ;
		}
		
		public isAnalog():boolean {
			return (this.type == ConnectorType.AnalogOutput) || (this.type == ConnectorType.AnalogInput);
		}
		
		// have this connector free space to connect anoter connection
		public haveFreeSpace():boolean {
			if (this.type == ConnectorType.DigitalInput || this.type == ConnectorType.AnalogInput) {
				return (this.connections.length == 0);
			}
			return true; // Other types have always free space
		}
		
		// This is "inner" method, call it only if you know what you do!!
		public _outputSetValue(value:number) {
			if (this.type == ConnectorType.DigitalOutput || this.type == ConnectorType.AnalogOutput) {
				if (this.value == value) return;
				this.value = value;
				this.connections.forEach(connection => {
					var cOther:Connector = connection.getOtherConnector(this);
					cOther._inputSetValue(value);
				});
				this.block._outputsChanged();
				return;
			}
			console.log("Cannot call setValue on not-output connectors!");
		}
		
		// This is "inner" method, call it only if you know what you do!!
		public _inputSetValue(value: number) {
			if (this.type == ConnectorType.DigitalInput || this.type == ConnectorType.AnalogInput) {
				if (this.value == value) return;
				this.value = value;
				this.block._inputsChanged();
				return;
			} else if (this.type == ConnectorType.DigitalInputOr) {
				
				var newValue: number = 0;
				this.connections.forEach((connection: Connection) => {
					if (connection.getOtherConnector(this).value != 0) {
						newValue = 1;
					}
				});
				
				if (this.value == newValue) return;
				this.value = newValue;
				this.block._inputsChanged();
				return;
			} else if (this.type == ConnectorType.DigitalInputAnd) {
				
				var newValue: number = this.connections.length?1:0;
				this.connections.forEach((connection: Connection) => {
					if (connection.getOtherConnector(this).value == 0) {
						newValue = 0;
					}
				});
				
				if (this.value == newValue) return;
				this.value = newValue;
				this.block._inputsChanged();
				return;
			} else if (this.type == ConnectorType.DigitalInputXor) {
				
				var trueValuesCount = 0;
				this.connections.forEach((connection: Connection) => {
					if (connection.getOtherConnector(this).value != 0) {
						trueValuesCount++;
					}
				});
				
				var newValue: number = (trueValuesCount%2 == 1)?1:0;
				
				if (this.value == newValue) return;
				this.value = newValue;
				this.block._inputsChanged();
				return;
			}
			console.log("Cannot call _inputSetValue on not-inputs connectors!");
		}
	}
	
	export class Connection {
		public connectorA: Connector;
		public connectorB: Connector;
		
		public renderer: IConnectionRenderer;
		
		public constructor(connectorA: Connector, connectorB: Connector) {
			this.connectorA = connectorA;
			this.connectorB = connectorB;
		}
		
		public getOtherConnector(self: Connector):Connector {
			if (this.connectorA == self) {
				return this.connectorB;
			} else {
				return this.connectorA;
			}
		}
		
		public getInputConnector():Connector {
			if (this.connectorA.isInput()) return this.connectorA;
			return this.connectorB;
		}
		
		public getOutputConnector():Connector {
			if (this.connectorA.isOutput()) return this.connectorA;
			return this.connectorB;
		}
		
		public disconnect() {
			
			this.connectorA._removeConnection(this);
			this.connectorB._removeConnection(this);
			
			//TODO: think about better solution!
			Controller.getInstance()._removeConnection(this);
			
			this.getInputConnector()._inputSetValue(0);
			
			if (this.renderer) this.renderer.destroy();
			
		}
	}

	// Interface for block with possibility to got digital value
	export interface IDigitalInputBlock {
		setDigitalValue(value: boolean):void;
	}
	
	// Interface for block with possibility to got analog value
	export interface IAnalogInputBlock {
		setAnalogValue(value: number):void;
	}
	
	// Interface for block with possibility to put out digital value
	export interface IDigitalOutputBlock {
		registerDigitalValueChangeCallback(callback: (block: Block, value: boolean) => void):void;
	}
	
	// Interface for block with possibility to put out digital value
	export interface IAnalogOutputBlock {
		registerAnalogValueChangeCallback(callback: (block: Block, value: number) => void):void;
	}
	
	// Interface for block renderer
	export interface IBlockRenderer {
		refresh():void;
		destroy():void;
		getConnectorPosition(name:string):{x:number, y:number};
	}
	
	// Interface for connection renderer
	export interface IConnectionRenderer {
		refresh():void;
		destroy():void;
	}
	
	export enum ConfigPropertyType {Integer, Float, String, Boolean, JSString};
	
	export class ConfigProperty {
		
		public id: string;
		public displayName: string;
		public config: any;
		public type: ConfigPropertyType;
		
		public value: any;
		
		public constructor(type: ConfigPropertyType, id: string, displayName: string, defaultValue: any, config?: any) {
			this.type = type;
			this.id = id;
			this.displayName = displayName;
			this.config = config || {};
			
			this.value = defaultValue;
		}
		
	}

	// Block!
	export class Block {
		protected inputConnectors: Array<Connector>;
		protected outputConnectors: Array<Connector>;
		protected configProperties: Array<ConfigProperty>;
		
		public id: string;
		public hwId: string;
		
		public type: string;
		public visualType: string;
		
		public renderer: IBlockRenderer;
		
		// positions
		public x:number = 0;
		public y:number = 0;
		
		public constructor(id: string, type: string, visualType: string) {
			this.id = id;
			this.type = type;
			this.visualType = visualType;
			
			this.inputConnectors = new Array();
			this.outputConnectors = new Array();
			this.configProperties = new Array();
		}
		
		protected sendValueToOutputConnector(connector:Connector, value:number) {
			if (this.outputConnectors.indexOf(connector) != -1) {
				connector._outputSetValue(value);
			} else {
				console.log("Connector named "+connector.name+" is not output connector on block "+this.id);
			}
		}
		
		protected addOutputConnector(name: string, type: ConnectorType):Connector {
			if (type == ConnectorType.DigitalOutput || type == ConnectorType.AnalogOutput) {
				var connector: Connector = new Connector(this, name, type);
				this.outputConnectors.push(connector);
				return connector;
			}
			console.log("Cannot add connector with type "+type+" as output connector.");
			return null;
		}
		
		protected addInputConnector(name: string, type: ConnectorType):Connector {
			if (type == ConnectorType.DigitalInput || type == ConnectorType.DigitalInputAnd || type == ConnectorType.DigitalInputOr || type == ConnectorType.DigitalInputXor || type == ConnectorType.AnalogInput) {
				var connector: Connector = new Connector(this, name, type);
				this.inputConnectors.push(connector);
				return connector;
			}
			console.log("Cannot add connector with type "+type+" as input connector.");
			return null;
		}
		
		protected removeOutputConnector(connector: Connector):void {
			if (!connector) return;
			this.disconnectConnectionFromConnector(connector);
			var index = this.outputConnectors.indexOf(connector);
			if (index > -1) {
				this.outputConnectors.splice(index, 1);
			}
		}
		
		protected removeInputConnector(connector: Connector):void {
			if (!connector) return;
			this.disconnectConnectionFromConnector(connector);
			var index = this.inputConnectors.indexOf(connector);
			if (index > -1) {
				this.inputConnectors.splice(index, 1);
			}
		}
		
		protected addConfigProperty(type: ConfigPropertyType, id: string, displayName: string, defaultValue: any, config?: any) {
			var configProperty: ConfigProperty = new ConfigProperty(type, id, displayName, defaultValue, config);
			this.configProperties.push(configProperty);
			return configProperty;
		}
		
		public getInputConnectors():Array<Connector> {
			return this.inputConnectors;
		}
		
		public getOutputConnectors():Array<Connector> {
			return this.outputConnectors;
		}
		
		public getConfigProperties():Array<ConfigProperty> {
			return this.configProperties;
		}
		
		public _outputsChanged() {
			if (this.renderer) this.renderer.refresh();
		}
		
		public _inputsChanged() {
			this.inputsChanged();
			if (this.renderer) this.renderer.refresh();
		}
		
		public emitConfigsChanged() {
			this.configsChanged();
		}
		
		public getConfigData():any {
			var config = {};
			this.configProperties.forEach((configProperty: ConfigProperty) => {
				config[configProperty.id] = configProperty.value;
			});
			return config;
		}
		
		public getConfigPropertyById(id: string):ConfigProperty {
			var cp:ConfigProperty = null;
			this.configProperties.forEach((configProperty: ConfigProperty) => {
				if (configProperty.id == id) {
					cp = configProperty;
				}
			});
			return cp;
		}
		
		public setConfigData(json: any):void {
			
			for (var key in json) {
				if (json.hasOwnProperty(key)) {
					var cp:ConfigProperty = this.getConfigPropertyById(key);
					cp.value = json[key];
				}
			}
			
			this.emitConfigsChanged();
			
		}
		
		private disconnectConnectionFromConnector(connector: Connector):void {
			var toDisconnect: Array<Connection> = connector.connections.splice(0);
			toDisconnect.forEach((connection: Connection) => {
				connection.disconnect();
			});
		}
		
		public remove():void {
			
			this.inputConnectors.forEach((connector: Connector) => {
				this.disconnectConnectionFromConnector(connector);
			});
			this.outputConnectors.forEach((connector: Connector) => {
				this.disconnectConnectionFromConnector(connector);
			});
			
			if (this.renderer) this.renderer.destroy();
			
			Controller.getInstance()._removeBlock(this);
		}
		
		public getOutputConnectorByName(name: string):Connector {
			var connector: Connector = null;
			this.outputConnectors.forEach((c: Connector) => {
				if (c.name == name) {
					connector = c;
				}
			});
			return connector;
		}
		
		public getInputConnectorByName(name: string):Connector {
			var connector: Connector = null;
			this.inputConnectors.forEach((c: Connector) => {
				if (c.name == name) {
					connector = c;
				}
			});
			return connector;
		}
		
		// ---- TO OVERRIDE ----
		public inputsChanged():void {
			console.log("Method inputsChanged is not overrided in block "+this.type);
			// OVERRIDE ME!!!
		}
		
		public configsChanged():void {
			//console.log("Method configsChanged is not overrided in block "+this.type);
			// OVERRIDE ME!!!
		}
		
		public rendererGetBlockBackgroundColor():string {
			// OVERRIDE ME!!!
			return "#ccc"; // default
		}
		
		public rendererGetDisplayName():string {
			return this.visualType;
		}
		
	}

}