import {BlockoCore} from "./BlockoCore";

export module BlockoBasicBlocks {

	export class Manager {
		static getAllBlocks():Array<BlockoCore.BlockClass> {
			return [
				BlockoBasicBlocks.Switch,
				BlockoBasicBlocks.PushButton,
				BlockoBasicBlocks.Light,
				BlockoBasicBlocks.And,
				BlockoBasicBlocks.Or,
				BlockoBasicBlocks.Xor,
				BlockoBasicBlocks.Not,
				BlockoBasicBlocks.FlipFlop,
				BlockoBasicBlocks.DelayTimer,
				BlockoBasicBlocks.AsyncGenerator,
				BlockoBasicBlocks.JSBlock,
				BlockoBasicBlocks.AnalogInput,
				BlockoBasicBlocks.AnalogOutput,
				BlockoBasicBlocks.AnalogRange
			];
		}
	}
	
	// Universal blocks parents:
	
	export class DigitalInput extends BlockoCore.Block implements BlockoCore.IDigitalInputBlock {
		
		public connectorOutput: BlockoCore.Connector;
		
		protected value:boolean = false;
		
		public constructor(id: string, visibleType: string) {
			super(id, "digitalInput", visibleType);
			this.connectorOutput = this.addOutputConnector("output", BlockoCore.ConnectorType.DigitalOutput);
		}
		
		public setDigitalValue(value: boolean):void {
			this.value = value;
			this.sendValueToOutputConnector(this.connectorOutput, value?1:0);
		}
		
		public inputsChanged() {
		}
		
		public rendererGetBlockBackgroundColor():string {
			if (this.value) {
				return "#FFCCCC";
			} else {
				return "#CCCCFF";
			}
		}
		
	}
	
	export class DigitalOutput extends BlockoCore.Block implements BlockoCore.IDigitalOutputBlock {
		
		public connectorInput: BlockoCore.Connector;
		
		protected value:boolean = false;
		
		public constructor(id: string, visibleType: string) {
			super(id, "digitalOutput", visibleType);
			this.connectorInput = this.addInputConnector("input", BlockoCore.ConnectorType.DigitalInputOr);
		}
		
		private digitalValueChangeCallback: (block: BlockoCore.Block, value: boolean) => void;
		public registerDigitalValueChangeCallback(callback: (block: BlockoCore.Block, value: boolean) => void):void {
			this.digitalValueChangeCallback = callback;
		}
		
		public inputsChanged() {
			this.value = this.connectorInput.value!=0?true:false;
			if (this.digitalValueChangeCallback) {
				this.digitalValueChangeCallback(this,this.value);
			}
		}
		
		public rendererGetBlockBackgroundColor():string {
			if (this.value) {
				return "#FFCCCC";
			} else {
				return "#CCCCFF";
			}
		}
		
	}
	
	// Blocks childs:
	
	export class Switch extends DigitalInput {
		
		private configHwId: BlockoCore.ConfigProperty;
		
		public constructor(id: string) {
			super(id, "switch");
			this.hwId = id; // TODO: change it!
			
			this.configHwId = this.addConfigProperty(BlockoCore.ConfigPropertyType.String, "hwId", "HW ID", id);
		}
		
		public configsChanged() {
			this.hwId = this.configHwId.value;
		}
		
		public rendererGetDisplayName():string {
			return (this.value)?"[MI]\uE834":"[MI]\uE835";
		}
		
	}
	
	export class PushButton extends DigitalInput {
		
		private configHwId: BlockoCore.ConfigProperty;
		
		public constructor(id: string) {
			super(id, "pushButton");
			this.hwId = id; // TODO: change it!
			
			this.configHwId = this.addConfigProperty(BlockoCore.ConfigPropertyType.String, "hwId", "HW ID", id);
		}
		
		public configsChanged() {
			this.hwId = this.configHwId.value;
		}
		
		public rendererGetDisplayName():string {
			return (this.value)?"[MI]\uE837":"[MI]\uE836";
		}
		
	}
	
	export class Light extends DigitalOutput {
		
		private configHwId: BlockoCore.ConfigProperty;
		
		public constructor(id: string) {
			super(id, "light");
			this.hwId = id; // TODO: change it!
			
			this.configHwId = this.addConfigProperty(BlockoCore.ConfigPropertyType.String, "hwId", "HW ID", id);
		}
		
		public configsChanged() {
			this.hwId = this.configHwId.value;
		}
		
		public rendererGetDisplayName():string {
			return (this.value)?"[MI]\uE3AC":"[MI]\uE3AA";
		}
		
	}
	
	// Basic blocks:
	
	export class And extends BlockoCore.Block {
		
		public connectorInput: BlockoCore.Connector;
		public connectorOutput: BlockoCore.Connector;
		
		public constructor(id: string) {
			super(id, "and", "and");
			this.connectorInput = this.addInputConnector("input", BlockoCore.ConnectorType.DigitalInputAnd);
			this.connectorOutput = this.addOutputConnector("output", BlockoCore.ConnectorType.DigitalOutput);
		}
		
		public inputsChanged() {
			this.sendValueToOutputConnector(this.connectorOutput, this.connectorInput.value);
		}
		
		public rendererGetBlockBackgroundColor():string {
			return "#a1887f";
		}
		
		public rendererGetDisplayName():string {
			return "AND";
		}
		
	}
	
	export class Or extends BlockoCore.Block {
		
		public connectorInput: BlockoCore.Connector;
		public connectorOutput: BlockoCore.Connector;
		
		public constructor(id: string) {
			super(id, "or", "or");
			this.connectorInput = this.addInputConnector("input", BlockoCore.ConnectorType.DigitalInputOr);
			this.connectorOutput = this.addOutputConnector("output", BlockoCore.ConnectorType.DigitalOutput);
		}
		
		public inputsChanged() {
			this.sendValueToOutputConnector(this.connectorOutput, this.connectorInput.value);
		}
		
		public rendererGetBlockBackgroundColor():string {
			return "#a1887f";
		}
		
		public rendererGetDisplayName():string {
			return "OR";
		}
		
	}
	
	export class Xor extends BlockoCore.Block {
		
		public connectorInput: BlockoCore.Connector;
		public connectorOutput: BlockoCore.Connector;
		
		public constructor(id: string) {
			super(id, "xor", "xor");
			this.connectorInput = this.addInputConnector("input", BlockoCore.ConnectorType.DigitalInputXor);
			this.connectorOutput = this.addOutputConnector("output", BlockoCore.ConnectorType.DigitalOutput);
		}
		
		public inputsChanged() {
			this.sendValueToOutputConnector(this.connectorOutput, this.connectorInput.value);
		}
		
		public rendererGetBlockBackgroundColor():string {
			return "#a1887f";
		}
		
		public rendererGetDisplayName():string {
			return "XOR";
		}
		
	}
	
	export class Not extends BlockoCore.Block {
		
		public connectorInput: BlockoCore.Connector;
		public connectorOutput: BlockoCore.Connector;
		
		public constructor(id: string) {
			super(id, "not", "not");
			this.connectorInput = this.addInputConnector("input", BlockoCore.ConnectorType.DigitalInput);
			this.connectorOutput = this.addOutputConnector("output", BlockoCore.ConnectorType.DigitalOutput);
		}
		
		public inputsChanged() {
			this.sendValueToOutputConnector(this.connectorOutput, (this.connectorInput.value==0)?1:0);
		}
		
		public rendererGetBlockBackgroundColor():string {
			return "#a1887f";
		}
		
		public rendererGetDisplayName():string {
			return "NOT";
		}
		
	}
	
	// Extended blocks:
	
	export class FlipFlop extends BlockoCore.Block {
		public connectorInput: BlockoCore.Connector;
		public connectorOutput: BlockoCore.Connector;
		public connectorOutputNeg: BlockoCore.Connector;
		
		
		private lastInputValue: number = 0;
		
		public constructor(id: string) {
			super(id, "flipFlop", "flipFlop");
			this.connectorInput = this.addInputConnector("input", BlockoCore.ConnectorType.DigitalInput);
			this.connectorOutput = this.addOutputConnector("output", BlockoCore.ConnectorType.DigitalOutput);
			this.connectorOutputNeg = this.addOutputConnector("outputNeg", BlockoCore.ConnectorType.DigitalOutput);
			this.connectorOutputNeg.value = 1;
		
		}
		
		public inputsChanged() {
			if (this.connectorInput.value != this.lastInputValue) {
				// nabezna hrana!
				if (this.connectorInput.value > this.lastInputValue) {
					this.sendValueToOutputConnector(this.connectorOutput, (this.connectorOutput.value==0?1:0));
					this.sendValueToOutputConnector(this.connectorOutputNeg, (this.connectorOutputNeg.value==0?1:0));
				}
				this.lastInputValue = this.connectorInput.value;
			}
		}
		
		public rendererGetBlockBackgroundColor():string {
			return "#90a4ae";
		}
		
		public rendererGetDisplayName():string {
			return "[MI]\uE040";
		}
	}
	
	export class DelayTimer extends BlockoCore.Block {
		
		public connectorInput: BlockoCore.Connector;
		public connectorOutput: BlockoCore.Connector;
		
		public configTime: BlockoCore.ConfigProperty;
		
		private lastInputValue: number = 0;
		
		private timeoutHandle: number = null;
		
		public constructor(id: string) {
			super(id, "delayTimer", "delayTimer");
			this.connectorInput = this.addInputConnector("input", BlockoCore.ConnectorType.DigitalInput);
			this.connectorOutput = this.addOutputConnector("output", BlockoCore.ConnectorType.DigitalOutput);
			
			this.configTime = this.addConfigProperty(BlockoCore.ConfigPropertyType.Float, "time", "Time", 5.0, { displayUnit: "sec" });
			
		}
		
		public inputsChanged() {
			if (this.connectorInput.value != this.lastInputValue) { // pouze zmena
				if (this.connectorInput.value > this.lastInputValue) { // nabezna hrana
					
					clearTimeout(this.timeoutHandle);
					this.sendValueToOutputConnector(this.connectorOutput, 1);
					
				} else { // sestupna hrana
				
					this.timeoutHandle = setTimeout(() => {
						this.sendValueToOutputConnector(this.connectorOutput, 0);
					}, this.configTime.value * 1000);
					
				}
				this.lastInputValue = this.connectorInput.value;
			}
		}
		
		public rendererGetBlockBackgroundColor():string {
			return "#90a4ae";
		}
		
		public rendererGetDisplayName():string {
			return "[MI]\uE190";
		}
		
	}
	
	export class AsyncGenerator extends BlockoCore.Block {
		
		public connectorEnabled: BlockoCore.Connector;
		public connectorOutput: BlockoCore.Connector;
		
		public configTimeDown: BlockoCore.ConfigProperty;
		public configTimeUp: BlockoCore.ConfigProperty;
		public configStartUp: BlockoCore.ConfigProperty;
		
		private lastInputValue: number = 0;
		
		public constructor(id: string) {
			super(id, "asyncGenerator", "asyncGenerator");
			this.connectorEnabled = this.addInputConnector("enabled", BlockoCore.ConnectorType.DigitalInput);
			this.connectorOutput = this.addOutputConnector("output", BlockoCore.ConnectorType.DigitalOutput);
			
			this.configStartUp = this.addConfigProperty(BlockoCore.ConfigPropertyType.Boolean, "startUp", "Start up", true);
			this.configTimeDown = this.addConfigProperty(BlockoCore.ConfigPropertyType.Float, "timeDown", "Down time", 1.0, { displayUnit: "sec" });
			this.configTimeUp = this.addConfigProperty(BlockoCore.ConfigPropertyType.Float, "timeUp", "Up time", 1.0, { displayUnit: "sec" });
			
		}
		
		private timeoutUpHandle: number;
		private timeoutDownHandle: number;
		
		private timerUp() {
			this.sendValueToOutputConnector(this.connectorOutput, 1);
			this.timeoutUpHandle = setTimeout(() => {
				this.timerDown();
			}, this.configTimeUp.value * 1000);
		}
		
		private timerDown() {
			this.sendValueToOutputConnector(this.connectorOutput, 0);
			this.timeoutDownHandle = setTimeout(() => {
				this.timerUp();
			}, this.configTimeDown.value * 1000);
		}
		
		private timerStop() {
			clearTimeout(this.timeoutUpHandle);
			clearTimeout(this.timeoutDownHandle);
			this.sendValueToOutputConnector(this.connectorOutput, 0);
		}
		
		public inputsChanged() {
			if (this.connectorEnabled.value != this.lastInputValue) { // pouze zmena
				if (this.connectorEnabled.value > this.lastInputValue) { // nabezna hrana
					
					if (this.configStartUp.value) {
						this.timerUp();
					} else {
						this.timerDown();
					}
					
				} else { // sestupna hrana
					
					this.timerStop();
					
				}
				this.lastInputValue = this.connectorEnabled.value;
			}
		}
		
		public rendererGetBlockBackgroundColor():string {
			return "#90a4ae";
		}
		
		public rendererGetDisplayName():string {
			return "[MI]\uE336";
		}
		
	}
	
	export class JSBlock extends BlockoCore.Block {

		public configJs: BlockoCore.ConfigProperty;
		
		public configDigitalInputsCount: BlockoCore.ConfigProperty;
		public configAnalogInputsCount: BlockoCore.ConfigProperty;
		public configDigitalOutputsCount: BlockoCore.ConfigProperty;
		public configAnalogOutputsCount: BlockoCore.ConfigProperty;
		
		public jsEngine: any;
		
		public constructor(id: string) {
			super(id, "jsBlock", "jsBlock");
			
			this.configDigitalInputsCount = this.addConfigProperty(BlockoCore.ConfigPropertyType.Integer, "digitalInputsCount", "Počet <b>din</b>", 1, { range: true, min: 0, max: 10 });
			this.configAnalogInputsCount = this.addConfigProperty(BlockoCore.ConfigPropertyType.Integer, "analogInputsCount", "Počet <b>ain</b>", 1, { range: true, min: 0, max: 10 });
			this.configDigitalOutputsCount = this.addConfigProperty(BlockoCore.ConfigPropertyType.Integer, "digitalOutputsCount", "Počet <b>dout</b>", 1, { range: true, min: 0, max: 10 });
			this.configAnalogOutputsCount = this.addConfigProperty(BlockoCore.ConfigPropertyType.Integer, "analogOutputsCount", "Počet <b>aout</b>", 1, { range: true, min: 0, max: 10 });
			
			
			this.configJs = this.addConfigProperty(BlockoCore.ConfigPropertyType.JSString, "configJs", "JavaScript", "block.displayName = \"JS\";\nblock.backgroundColor = \"orange\";\n\nblock.inputsChanged = function () {\n\tblock.dout1(block.din1());\n\tblock.aout1(block.ain1());\n};");
			
			this.configsChanged();
		}
		
		public inputsChanged() {
			if (this.jsEngine && this.jsEngine.inputsChanged && typeof this.jsEngine.inputsChanged == "function") {
				
				try {
					this.jsEngine.inputsChanged();
				} catch (error) {
					console.error(error);
					alert("JavaScript error in inputsChanged of block "+this.id+" (name:"+this.rendererGetDisplayName()+") error: "+error);
				}
				
			}
		}
		
		public configsChanged() {
			
			var digitalInputsCount:Number = this.configDigitalInputsCount.value;
			var wantedDigitalInputNames:Array<string> = [];
			for (var i = 0; i < digitalInputsCount; i++) {
				wantedDigitalInputNames.push("din"+(i+1));
			}
			
			var digitalOutputsCount:Number = this.configDigitalOutputsCount.value;
			var wantedDigitalOutputNames:Array<string> = [];
			for (var i = 0; i < digitalOutputsCount; i++) {
				wantedDigitalOutputNames.push("dout"+(i+1));
			}
			
			var analogInputsCount:Number = this.configAnalogInputsCount.value;
			var wantedAnalogInputNames:Array<string> = [];
			for (var i = 0; i < analogInputsCount; i++) {
				wantedAnalogInputNames.push("ain"+(i+1));
			}
			
			var analogOutputsCount:Number = this.configAnalogOutputsCount.value;
			var wantedAnalogOutputNames:Array<string> = [];
			for (var i = 0; i < analogOutputsCount; i++) {
				wantedAnalogOutputNames.push("aout"+(i+1));
			}
			
			var inputConnectors = this.getInputConnectors();
			var outputConnectors = this.getOutputConnectors();
			
			var inputsToDelete:Array<string> = [];
			var outputsToDelete:Array<string> = [];
			
			inputConnectors.forEach((connector: BlockoCore.Connector) => {
				inputsToDelete.push(connector.name);
			});
			
			outputConnectors.forEach((connector: BlockoCore.Connector) => {
				outputsToDelete.push(connector.name);
			});
			
			// inputs
			
			wantedDigitalInputNames.forEach((name:string) => {
				var connector = this.getInputConnectorByName(name);
				if (!connector) {
					this.addInputConnector(name, BlockoCore.ConnectorType.DigitalInput);
				}
				var i = inputsToDelete.indexOf(name);
				if (i > -1) {
					inputsToDelete.splice(i, 1);
				}
			});
			
			wantedAnalogInputNames.forEach((name:string) => {
				var connector = this.getInputConnectorByName(name);
				if (!connector) {
					this.addInputConnector(name, BlockoCore.ConnectorType.AnalogInput);
				}
				var i = inputsToDelete.indexOf(name);
				if (i > -1) {
					inputsToDelete.splice(i, 1);
				}
			});
			
			inputsToDelete.forEach((name:string) => {
				var connector = this.getInputConnectorByName(name);
				this.removeInputConnector(connector);
			});
			
			// outputs
			
			wantedDigitalOutputNames.forEach((name:string) => {
				var connector = this.getOutputConnectorByName(name);
				if (!connector) {
					this.addOutputConnector(name, BlockoCore.ConnectorType.DigitalOutput);
				}
				var i = outputsToDelete.indexOf(name);
				if (i > -1) {
					outputsToDelete.splice(i, 1);
				}
			});
			
			wantedAnalogOutputNames.forEach((name:string) => {
				var connector = this.getOutputConnectorByName(name);
				if (!connector) {
					this.addOutputConnector(name, BlockoCore.ConnectorType.AnalogOutput);
				}
				var i = outputsToDelete.indexOf(name);
				if (i > -1) {
					outputsToDelete.splice(i, 1);
				}
			});
			
			outputsToDelete.forEach((name:string) => {
				var connector = this.getOutputConnectorByName(name);
				this.removeOutputConnector(connector);
			});
			
			var connectorSortFunction = (ca:BlockoCore.Connector, cb:BlockoCore.Connector) => {
				if (ca.isAnalog() && !cb.isAnalog()) {
					return 1;
				}
				if (!ca.isAnalog() && cb.isAnalog()) {
					return -1;
				}
				return ca.name.localeCompare(cb.name);
			};
			
			inputConnectors.sort(connectorSortFunction);
			outputConnectors.sort(connectorSortFunction);
			
			// JS engine
			
			var jsEngineFucntions = {
				getInputValue: (inputName) => {
					var connector: BlockoCore.Connector = this.getInputConnectorByName(inputName);
					if (connector) {
						return connector.value;
					}
					return 0;
				},
				setOutputValue: (outputName, value) => {
					var connector: BlockoCore.Connector = this.getOutputConnectorByName(outputName);
					if (connector) {
						this.sendValueToOutputConnector(connector, value);
					}
				}
			};
			
			inputConnectors.forEach((connector:BlockoCore.Connector) => {
				var name = connector.name;
				jsEngineFucntions[name] = () => {
					var connector: BlockoCore.Connector = this.getInputConnectorByName(name);
					if (connector) {
						return connector.value;
					}
					return 0;
				};
			});
			
			outputConnectors.forEach((connector:BlockoCore.Connector) => {
				var name = connector.name;
				jsEngineFucntions[name] = (value) => {
					var connector: BlockoCore.Connector = this.getOutputConnectorByName(name);
					if (connector) {
						this.sendValueToOutputConnector(connector, value);
					}
				};
			});
			
			try {
				
				var jsEngineStr = "'use strict'; var window, document, location, self, name, history, parent, screen, jQuery, $, Snap; var block = _block_model_ || {}; (function() { "+this.configJs.value+"; })(); return block;";
				var jsEngineFunction = new Function("_block_model_", jsEngineStr);
				this.jsEngine = jsEngineFunction(jsEngineFucntions);
				
			} catch (error) {
				alert("JavaScript code cannot load with error: "+error);
			}
			
			// refresing
			this.inputsChanged();
			if (this.renderer) this.renderer.refresh();
			
		}
		
		public rendererGetDisplayName():string {
			if (this.jsEngine && this.jsEngine.displayName) {
				if (typeof this.jsEngine.displayName == "string") {
					return  this.jsEngine.displayName;
				} else if (typeof this.jsEngine.displayName == "function") {
					return  this.jsEngine.displayName();
				}
			}
			return "JS";
		}
		
		public rendererGetBlockBackgroundColor():string {
			if (this.jsEngine && this.jsEngine.backgroundColor) {
				if (typeof this.jsEngine.backgroundColor == "string") {
					return  this.jsEngine.backgroundColor;
				} else if (typeof this.jsEngine.backgroundColor == "function") {
					return  this.jsEngine.backgroundColor();
				}
			}
			return "#cfc";
		}
		
	}
	
	// ANALOG:
	
	export class AnalogInput extends BlockoCore.Block implements BlockoCore.IAnalogInputBlock {
		
		public connectorOutput: BlockoCore.Connector;
		
		private configHwId: BlockoCore.ConfigProperty;
		
		protected value:number = 0;
		
		public constructor(id: string) {
			super(id, "analogInput", "analogInput");
			this.connectorOutput = this.addOutputConnector("output", BlockoCore.ConnectorType.AnalogOutput);
			this.hwId = id; // TODO: change it!
			
			this.configHwId = this.addConfigProperty(BlockoCore.ConfigPropertyType.String, "hwId", "HW ID", id);
		}
		
		public setAnalogValue(value: number):void {
			this.value = value;
			this.sendValueToOutputConnector(this.connectorOutput, value);
		}
		
		public inputsChanged() {
		}
		
		public configsChanged() {
			this.hwId = this.configHwId.value;
		}
		
		public rendererGetBlockBackgroundColor():string {
			return "#CCFFCC";
		}
		
		public rendererGetDisplayName():string {
			return "0";
		}
		
	}
	
	export class AnalogOutput extends BlockoCore.Block implements BlockoCore.IAnalogOutputBlock {
		
		public connectorInput: BlockoCore.Connector;
		
		private configHwId: BlockoCore.ConfigProperty;
		
		protected value:number = 0;
		
		public constructor(id: string) {
			super(id, "analogOutput", "analogOutput");
			this.connectorInput = this.addInputConnector("input", BlockoCore.ConnectorType.AnalogInput);
			this.hwId = id; // TODO: change it!
			
			this.configHwId = this.addConfigProperty(BlockoCore.ConfigPropertyType.String, "hwId", "HW ID", id);
		}
		
		private analogValueChangeCallback: (block: BlockoCore.Block, value: number) => void;
		public registerAnalogValueChangeCallback(callback: (block: BlockoCore.Block, value: number) => void):void {
			this.analogValueChangeCallback = callback;
		}
		
		public inputsChanged() {
			this.value = this.connectorInput.value;
			if (this.analogValueChangeCallback) {
				this.analogValueChangeCallback(this,this.value);
			}
		}
		
		public configsChanged() {
			this.hwId = this.configHwId.value;
		}
		
		public rendererGetBlockBackgroundColor():string {
			return "#CCFFCC";
		}
		
		public rendererGetDisplayName():string {
			return this.value.toFixed(1);
		}
		
	}
	
	export class AnalogRange extends BlockoCore.Block {
		
		public connectorInput: BlockoCore.Connector;
		public connectorOutput: BlockoCore.Connector;
		
		public configMin: BlockoCore.ConfigProperty;
		public configMax: BlockoCore.ConfigProperty;
		
		public constructor(id: string) {
			super(id, "analogRange", "analogRange");
			this.connectorInput = this.addInputConnector("input", BlockoCore.ConnectorType.AnalogInput);
			this.connectorOutput = this.addOutputConnector("output", BlockoCore.ConnectorType.DigitalOutput);
			
			this.configMin = this.addConfigProperty(BlockoCore.ConfigPropertyType.Float, "min", "Min", 0.5);
			this.configMax = this.addConfigProperty(BlockoCore.ConfigPropertyType.Float, "max", "Max", 1.5);
		}
		
		public configsChanged() {
			this.inputsChanged();
		}
		
		public inputsChanged() {
			if (this.configMin.value <= this.connectorInput.value && this.connectorInput.value <= this.configMax.value) {
				this.sendValueToOutputConnector(this.connectorOutput, 1);
			} else {
				this.sendValueToOutputConnector(this.connectorOutput, 0);
			}
		}
		
		public rendererGetBlockBackgroundColor():string {
			return "#90a4ae";
		}
		
		public rendererGetDisplayName():string {
			return "[MI]\uE259";
		}
		
	}
	
}